{
    "collab_server" : "",
    "contents" : "###############################################################\n#'Get datasource connection\n#'\n#' This is a function to obtain connection to a\n#' datasource from the envision server by providing the token\n#' obtained from the envision App for the specific datasource\n#'\n#' @param baseUrl - CA server URL\n#' @param token - Token for the datasource\n#'                    obtained from the App\n#' @param apiKey  - ApiKey for the user/company\n#' @export\nconnect.ca <- function(url, token, apiKey) {\n  # //////////////////////////////////////////////////////\n  BAConnectionData <- R6::R6Class(\n    \"BAConnectionData\",\n    public = list (\n      factTable = \"\",\n      jdbc = NULL,\n      columns = NULL,\n      engineType = NULL,\n      ba2DBTypes = NULL,\n      q = NULL,\n      username = \"\",\n      initialize = function(factTable,\n                            jdbc,\n                            columns,\n                            ba2DBTypes,\n                            qVar,\n                            uname) {\n        self$factTable <- factTable\n        self$jdbc <- jdbc\n        self$columns <- columns\n        self$ba2DBTypes <- ba2DBTypes\n        self$q <- qVar\n        self$username <- uname\n      },\n\n      quot = function(attribute) {\n        tmp <- \"\"\n        tmp <- paste(self$q, attribute, self$q, sep = \"\")\n        tmp\n      },\n\n      finalize = function() {\n        if (!is.null(jdbc))\n          RJDBC::dbDisconnect(jdbc)\n      }\n    )\n  )\n\n  # //////////////////////////////////////////////////////\n  BAConnection <- R6::R6Class(\n    \"BAConnection\",\n    private = list(\n      conn_data = '',\n      createTable = function(df, colName, type) {\n        if (is.null(colName))\n          stop(\"Invalid column name\")\n        #\n        # temp <- gsub(\"\\\"\",\"\",private$conn_data$factTable)\n        # temp <- unlist(strsplit(temp,split = \"[.]\"))\n        # dsName <- NULL\n        # schema <- NULL\n        # if(length(temp) > 1){\n        #   schema <- temp[1]\n        #   dsName <- temp[2]\n        # }\n        # else\n        #   dsName <- temp\n        #\n        # tableName <- paste(dsName,colName, sep=\"_\")\n        #\n        # # If module is parameterized append the userName as well _<USERNAME> to tableName\n        # if(carriots.analytics.isParametrised)\n        #   tableName <- paste(tableName,private$conn_data$username, sep=\"_\")\n        #\n        # print(tableName)\n        # md5table <- digest::digest(tableName,\"md5\",serialize = FALSE)\n        #\n        # print(md5table)\n        # md5table <- private$conn_data$quot(md5table)\n        # if(!is.null(schema))\n        #   md5table <- paste(private$conn_data$quot(schema),md5table,sep=\".\")\n        #\n\t\ttemp <- gsub(\"\\\"\",\"\",carriots.analytics.fact_table_name)\n        temp <- unlist(strsplit(temp, split = \"[.]\"))\n        dsName <- NULL\n        schema <- NULL\n        if (length(temp) > 1) {\n          schema <- temp[1]\n          dsName <- temp[2]\n        }\n        else\n          dsName <- temp\n\n        md5table <- private$conn_data$quot(dsName)\n        if (!is.null(schema))\n          md5table <-\n          paste(private$conn_data$quot(schema), md5table, sep = \".\")\n\n        private$dropIfExists(md5table)\n\n        colNames <- colnames(df)\n        colNames <- colNames[colNames != colName]\n\n        if (!all(colNames %in% self$getColumnNames()))\n          stop(\"Data Frame has more than one new column compared to fact table\")\n\n        query <- \"CREATE TABLE\"\n        query <- paste(query, md5table, \"AS\")\n        colString <-\n          paste(private$conn_data$quot(colNames), \",\", collapse = \"\")\n        colString <- substr(colString, 1, nchar(colString) - 1)\n\n        orgQuery <-\n          paste(\"(\",\n                \"SELECT\",\n                colString,\n                \"FROM\",\n                private$conn_data$factTable,\n                \"WHERE 1=2\",\n                \")\")\n        query <- paste(query, orgQuery)\n\n        print(query)\n        RJDBC::dbSendUpdate(private$conn_data$jdbc, query)\n\n        #Add a column first\n        private$addColumn(md5table, name = colName, type = type)\n\n        md5table\n\n\n      },\n      addColumn = function(md5table,\n                           name = NULL,\n                           type = NULL,\n                           default = NULL) {\n        if (is.null(name) | is.null(type))\n          stop(\"Column name or type is empty\")\n\n        if (!(type %in% names(private$conn_data$ba2DBTypes)))\n          stop(paste(\"Invalid Type selected\", \"-\", type))\n\n        alterQuery <- \"ALTER TABLE\"\n        alterQuery <-\n          paste(\n            alterQuery,\n            md5table,\n            \"ADD COLUMN\",\n            private$conn_data$quot(name),\n            private$conn_data$ba2DBTypes[[type]]\n          )\n        if (!is.null(default)) {\n          alterQuery <- paste(alterQuery, \"NOT NULL DEFAULT\")\n          if (is.numeric(default))\n            alterQuery <- paste(alterQuery, \" (\", default, \") \", sep = \"\")\n          else\n            alterQuery <- paste(alterQuery, \" '\", default, \"' \", sep = \"\")\n        }\n        print(alterQuery)\n        RJDBC::dbSendUpdate(private$conn_data$jdbc, alterQuery)\n      },\n\n      insertData = function(tablename, dataframe) {\n        if (nrow(dataframe) < 1)\n          stop(\"No data available in dataframe\")\n\n        query <- \"INSERT INTO\"\n        query <- paste(query, tablename)\n        colNames <- paste(\"\\\"\", colnames(dataframe), \"\\\"\", sep = \"\")\n        query <- paste(query, \"(\", paste(colNames, collapse = \",\"), \")\")\n\n        print(paste(\"intial--->\",query))\n\n        query <- paste(query, \"VALUES\")\n\n        values <- \"\"\n\n        for (i in 1:nrow(dataframe)) {\n          if (i > 1)\n            values <- paste(values, \",\")\n          row <- dataframe[i, ]\n          #string values are printed with index\n          #values <- paste(values,paste(\"(\",paste(paste(\"'\",row,\"'\",sep=\"\"),collapse=\",\"),\")\",sep = \"\"))\n          values <-\n            paste(values, paste(\"(\", paste(apply(row, 1, function(k) {\n              paste(paste(\"'\", k, \"'\", sep = \"\"), collapse = \",\")\n            })), \")\", sep = \"\"))\n        }\n\n        query <- paste(query, values)\n        print(query)\n\n        RJDBC::dbSendUpdate(private$conn_data$jdbc, query)\n\n      },\n\n      dropIfExists = function(tableName) {\n        t <- tableName\n        temp <- unlist(strsplit(t, split = \"[.]\"))\n        if (length(temp) > 1) {\n          RJDBC::dbSendUpdate(private$conn_data$jdbc, paste(\"set schema\", temp[1]))\n          t <- temp[2]\n        }\n\n        t <- gsub(\"\\\"\", \"\", t)\n\n        if (RJDBC::dbExistsTable(private$conn_data$jdbc, t)) {\n          RJDBC::dbRemoveTable(private$conn_data$jdbc,\n                               DBI::dbQuoteIdentifier(private$conn_data$jdbc, t))\n        }\n      }\n    ),\n    public = list (\n      dataTypes = '',\n      initialize = function(conn_data) {\n        private$conn_data <- conn_data\n        self$dataTypes <-\n          list(\n            STRING = \"STRING\",\n            NUMERIC = \"NUMERIC\",\n            INTEGER = \"INTEGER\",\n            DATE = \"DATE\",\n            DATETIME = \"DATETIME\",\n            TIME = \"TIME\"\n          )\n      },\n\n      load = function(columns = NULL) {\n        query <-\n          paste(\"SELECT \",\n                getColumns(colSelected = columns, private$conn_data),\n                sep = \"\")\n\n        query <- paste(query, \"FROM\", private$conn_data$factTable)\n        # if(!is.null(limit) & !is.na(limit) & limit > 0)\n        #   query <- paste(query, \"LIMIT\",limit)\n\n        df <- RJDBC::dbGetQuery(private$conn_data$jdbc, query)\n        col2Label <- getColumn2Label(private$conn_data$columns)\n        orgNames <- names(df)\n        for (i in 1:length(orgNames)) {\n          names(df)[i] <- col2Label[names(df)[i]]\n        }\n\n        df\n      },\n\n      close = function() {\n        RJDBC::dbDisconnect(private$conn_data$jdbc)\n      },\n\n      updateDataFrame = function(df = NULL,\n                                 colName = NULL,\n                                 type = NULL) {\n        if (is.na(df) || missing(colName))\n          stop(\"Required parameters were missing\")\n\n        if (!(colName %in% colnames(df)))\n          stop(\"Specified column doesnt exists in the data frame\")\n\n        label2Col <- private$conn_data$columns\n        orgNames <- names(df)\n        for (i in 1:length(orgNames)) {\n          if (orgNames[i] != colName) {\n            label <- label2Col[orgNames[i]]\n            if (is.null(label))\n              stop(\"Dataframe has an unexpected column\")\n            names(df)[i] <- label\n          } else {\n            if (exists(paste(\"carriots.analytics.dervived_dim_name\"))) {\n\t\t\t  carriots.analytics.dervived_dim_name <- gsub(\"\\\"\",\"\",carriots.analytics.dervived_dim_name)\n\t\t\t        print(paste(\"dimName------>\",carriots.analytics.dervived_dim_name))\n              names(df)[i] <- carriots.analytics.dervived_dim_name\n              colName <- carriots.analytics.dervived_dim_name\n            }\n\n          }\n        }\n\n        #create table\n        md5Table <- private$createTable(df, colName, type)\n\n        #insert in to new table\n        private$insertData(md5Table, df)\n\n        #Fire an event to reload the table in the app\n        params <-\n          list(dstoken = token,\n               dim = carriots.analytics.dervived_dim_name,\n               support_table = md5Table)\n        headerParams <- c('X-CA-apiKey' = apiKey)\n        res <- doHttpCall(url, \"reloadext\", params, headerParams)\n\n        res\n      },\n\n      getColumnNames = function() {\n        cols <- names(private$conn_data$columns)\n        cols\n      }\n    )\n  )\n\n  # //////////////////////////////////////////////////////\n  # Call the CA REST API to get the connection data\n  # Based on the engine type, get the appropriate JDBC driver\n  data <- getDatasourceConnection(url, token, apiKey)\n\n  jdbc <- data$jdbc\n  factTable <- data$ftable\n  columns <- data$columns\n  quot <- data$quot\n  ba2DBTypes <- getDataTypes(data$engineType)\n\n  connect_data <-\n    BAConnectionData$new(factTable, jdbc, columns, ba2DBTypes, quot, data$username)\n  conn <- BAConnection$new(connect_data)\n  conn\n}\n\n\n#################################################################################\n#' Method to load the table data\n#'\n#' User can pass the selected column names as the data frame returned by this\n#' method will have only the selected columns\n#'\n#' @param columns - vector of selected column names\n#' @param conn  - BAConnection object obtained from connect API\n#'\n#'@export\nload.ca = function(conn = NULL, columns = NULL) {\n  conn$load(columns = columns)\n}\n\n#################################################################################\n#' Method to update the data in the table\n#'\n#' Update the table with the values provided in the data frame. Below is the\n#' structure of the data frame for WhereClause\n#'\n#'  @param conn - BAConnection object obtained from connect API\n#'  @param dataframe - DataFrame for where Clause\n#'  @param colname -  colname in dataframe which is to be added in to table\n#'  @param type - Data type of column, supports specific types  available in the conn$dataTypes list\n#'\n#'@export\nupdate.ca = function(conn = NULL,\n                     dataframe = NULL,\n                     colname = NULL,\n                     type = NULL) {\n  conn$updateDataFrame(df = dataframe,\n                       colName = colname,\n                       type = type)\n}\n\n###############################################################################\n#'Reload Datasource\n#'\n#' Function to refresh the datasource in envision, which reflects\n#' the latest update\n#'\n#' @param baseUrl - Envision server URL\n#' @param token - Token for the datasource\n#'                    obtained from the App\n#' @param apiKey  - ApiKey for the user/company\n#'\n#' @export\nreloadDatasource.ca <- function(baseUrl, token, apiKey) {\n  headerParams <- c('X-CA-apiKey' = apiKey)\n  queryParams <- list(dstoken = token)\n  res <- doHttpCall(baseUrl, \"reloadext\", queryParams, headerParams)\n  res\n}\n\n##################################################################################\n# UTILITIES\n##################################################################################\nasc <- function(x) {\n  strtoi(charToRaw(x), 16L)\n}\n\nchr <- function(n) {\n  rawToChar(as.raw(n))\n}\n\n#supported data types - ba2DBTypes\n\ngetDataTypes <- function(engineType) {\n  dataTypes <-\n    list(\n      STRING = \"VARCHAR(256)\",\n      NUMERIC = \"DOUBLE\",\n      INTEGER = \"INT\",\n      DATE = \"DATE\",\n      DATETIME = \"TIMESTAMP\",\n      TIME = \"TIME\"\n    )\n\n  if (toupper(engineType) == \"ORACLE\") {\n    dataTypes$NUMERIC = \"NUMBER(20,4)\"\n    dataTypes$INTEGER = \"NUMBER(20)\"\n  }\n  else if (toupper(engineType) == \"MYSQL\") {\n    dataTypes$NUMERIC = \"DECIMAL(20,4)\"\n    dataTypes$TIMESTAMP = \"DATETIME\"\n  }\n  else if (toupper(engineType) == \"REDSHIFT\") {\n    dataTypes$NUMERIC = \"DOUBLE PRECISION\"\n    dataTypes$INTEGER = \"BIGINT\"\n  }\n\n  dataTypes\n}\n\ngetColumns <- function(colSelected = NULL, conn) {\n  cols <- conn$columns\n  colString <- \"\"\n  if (!is.null(colSelected) &  length(colSelected) > 0) {\n    length <- length(colSelected)\n    for (i in 1:length) {\n      if (i > 1 & i <= length)\n        colString <- paste(colString, \",\")\n      if (!is.null(cols[[colSelected[[i]]]])) {\n        colString <- paste(colString, conn$quot(cols[[colSelected[[i]]]]))\n      } else\n        stop(paste(\"ColName:\", colSelected[[i]], \"doesn't exists in the table\"))\n      i <- i + 1\n    }\n  } else\n    colString <- \"*\"\n\n  colString\n}\n\ngetColumn2Label <- function(colList) {\n  column <- paste(colList)\n  labels <- names(colList)\n\n  col2Label <- list()\n  for (i in 1:length(labels))\n    col2Label[column[i]] = labels[i]\n\n  col2Label\n\n}\n\n#-------------------------------------------------------------\n#'Get DataSource Meta data\n#'\n#' This is a function to obtain the meta data of a\n#' datasource from the envision server by providing the secret\n#' key of the datasource\n#'\n#' @param baseUrl - Envision server URL\n#' @param token - token for the datasource\n#'                    obtained from the App\n#' @param apiKey  - ApiKey for the user/company\n#--------------------------------------------------------------\ngetDataSourceMetaData <- function(baseUrl, token, apiKey) {\n  headerParams <- c('X-CA-apiKey' = apiKey)\n  queryParams <- list(dstoken = token)\n  res <- doHttpCall(baseUrl, \"dsExtConnect\", queryParams, headerParams)\n  res\n}\n\n#-----------------------------------------------------------------------\n#'Get DataSource Connection\n#'\n#' This is a function to obtain JDBC connection to a\n#' datasource from the envision server by providing the secret\n#' key of the datasource\n#'\n#' @param baseUrl - Envision server URL\n#' @param token - token for the datasource\n#'                    obtained from the App\n#' @param apiKey  - ApiKey for the user/company\n#-----------------------------------------------------------------------\ngetDatasourceConnection <- function(baseUrl, token, apiKey) {\n  data <- getDataSourceMetaData(baseUrl, token, apiKey)\n  if (!is.null(data$connect_data)) {\n    connect_data <- data$connect_data\n    jdbcDetails <- getDriverDetails(connect_data)\n    if (is.null(jdbcDetails$driverClass) ||\n        is.null(jdbcDetails$driver) || is.null(jdbcDetails$connString))\n      stop(\"Unable to create JDBC connection- required info missing\")\n\n    #decrypt password\n    passWord <- character()\n    encrypt <- strsplit(connect_data$password, \"\")[[1]]\n    for (i in 1:stringr::str_length(connect_data$password)) {\n      passWord[[i]] <- chr(asc(encrypt[[i]]) - 4)\n    }\n    decrypt <- paste(passWord, collapse = \"\")\n    passWord <- stringi::stri_reverse(decrypt)\n    passWord <- rawToChar(base64enc::base64decode(passWord))\n\n    #passPhrase <- digest::AES(connect_data$ftable,mode=\"CBC\")\n    #passPhrase <- substr(passPhrase,0,8)\n    #aes <- digest::AES(passPhrase,mode=\"CBC\")\n    jdbcDriver <- RJDBC::JDBC(\n      driverClass = jdbcDetails$driverClass,\n      classPath = system.file(\"extdata\", jdbcDetails$driver, package = \"envision\"),\n      identifier.quote = jdbcDetails$quot\n    )\n    conn <-\n      RJDBC::dbConnect(jdbcDriver,\n                       jdbcDetails$connString,\n                       connect_data$username,\n                       passWord)\n    ftable <- connect_data$ftable\n    data <- NULL\n    data$ftable <- ftable\n    data$username <- connect_data$user_login_name\n    data$jdbc <- conn\n    data$quot <- jdbcDetails$quot\n    data$columns <- connect_data$columns\n    data$engineType <- connect_data$engine_type\n\n  } else {\n    stop(\"Connect data of the datasource not available\")\n  }\n  data\n}\n\ndoHttpCall <-\n  function(baseUrl,\n           identifier,\n           queryParams,\n           headerParams) {\n    url_length <- stringr::str_length(baseUrl)\n\n    if (substr(baseUrl, url_length, url_length) == \"/\") {\n      baseUrl <- substr(baseUrl, 0, url_length - 1)\n    }\n\n    baseUrl <-\n      paste(baseUrl, \"/datasource.do?action=\", identifier, sep = \"\")\n\n    ua      <-\n      \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:33.0) Gecko/20100101 Firefox/33.0\"\n\n    doc <- httr::POST(baseUrl,\n                      httr::add_headers(.headers = headerParams),\n                      query = queryParams,\n                      httr::user_agent(ua))\n    res <- httr::content(doc, useInternalNodes = T)\n\n    data <- jsonlite::fromJSON(res)\n\n    data\n  }\n\ngetDriverDetails <- function(connect_data) {\n  if (is.null(connect_data$engine_type))\n    stop(\"Engine Type not found\")\n  engineType <- connect_data$engine_type\n\n  if (is.null(connect_data$hostname))\n    stop(\"Host Name not found\")\n  host_port <- connect_data$hostname\n\n  if (!is.null(connect_data$port))\n    host_port <- paste(host_port, connect_data$port, sep = \":\")\n\n  if (is.null(connect_data$dbName))\n    stop(\"DBName not found\")\n\n  jdbcDetails <- NULL\n  if (toupper(engineType) == \"MONETDB\") {\n    jdbcDetails$driverClass <- \"nl.cwi.monetdb.jdbc.MonetDriver\"\n    jdbcDetails$driver <- \"monetdb-jdbc-2.8.jar\"\n    jdbcDetails$connString <-\n      paste(\"jdbc:monetdb://\",\n            host_port,\n            \"/\",\n            connect_data$dbName,\n            sep = \"\")\n    jdbcDetails$quot <- \"\\\"\"\n\n  } else if (toupper(engineType) == \"MYSQL\") {\n    jdbcDetails$driverClass <- \"com.mysql.jdbc.Driver\"\n    jdbcDetails$driver <- \"mysql-connector-java-5.1.21-bin\"\n    jdbcDetails$connString <-\n      paste(\"jdbc:mysql://\", host_port, \"/\", connect_data$dbName, sep = \"\")\n    jdbcDetails$quot <- \"`\"\n\n  } else if (toupper(engineType) == \"POSTGRESQL\" ||\n             toupper(engineType) == \"REDSHIFT\") {\n    jdbcDetails$driverClass <- \"org.postgresql.Driver\"\n    jdbcDetails$driver <- \"postgresql-9.2-1002.jdbc4.jar\"\n    jdbcDetails$connString <-\n      paste(\"jdbc:postgresql://\",\n            host_port,\n            \"/\",\n            connect_data$dbName,\n            sep = \"\")\n    jdbcDetails$quot <- \"\\\"\"\n\n  } else if (toupper(engineType) == \"SQLSERVER\") {\n    jdbcDetails$driverClass <-\n      \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"\n    jdbcDetails$driver <- \"sqljdbc4.jar\"\n    jdbcDetails$connString <-\n      paste(\"jdbc:sqlserver://\",\n            getSQLServerConnString(connect_data),\n            sep = \"\")\n    jdbcDetails$quot <- \"\\\"\"\n\n  } else if (toupper(engineType) == \"ORACLE\") {\n    jdbcDetails$driverClass <- \"oracle.jdbc.driver.OracleDriver\"\n    jdbcDetails$driver <- \"ojdbc6.jar\"\n    jdbcDetails$connString <-\n      paste(\"jdbc:oracle:thin:@\",\n            host_port,\n            \"/\",\n            connect_data$dbName,\n            sep = \"\")\n    jdbcDetails$quot <- \"\\\"\"\n\n  } else if (toupper(engineType) == \"SUNDB\") {\n    jdbcDetails$driverClass <- \"sunje.sundb.jdbc.SundbDriver\"\n    jdbcDetails$driver <- \"sundb6.jar\"\n    jdbcDetails$connString <-\n      paste(\"jdbc:sundb://\", host_port, \"/\", connect_data$dbName, sep = \"\")\n    jdbcDetails$quot <- \"\\\"\"\n\n  } else if (toupper(engineType) == \"MARIADB\") {\n    jdbcDetails$driverClass <- \"org.mariadb.jdbc.Driver\"\n    jdbcDetails$driver <- \"mariadb-java-client-1.3.3.jar\"\n    jdbcDetails$connString <-\n      paste(\"jdbc:mariadb://\",\n            host_port,\n            \"/\",\n            connect_data$dbName,\n            sep = \"\")\n    jdbcDetails$quot <- \"\\\"\"\n  }\n\n  jdbcDetails\n}\n\ngetSQLServerConnString <- function(connect_data) {\n  conn_string <-\n    paste(connect_data$hostname, connect_data$dbName, sep = \"\\\\\")\n  if (!is.null(connect_data$port))\n    conn_string <- paste(conn_string, connect_data$port, sep = \":\")\n\n  conn_string\n}\n",
    "created" : 1503919936593.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3733885114",
    "id" : "115C6C1B",
    "lastKnownWriteTime" : 1512120924,
    "last_content_update" : 1512120924336,
    "path" : "~/envision/R/envision_connect.R",
    "project_path" : "R/envision_connect.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}